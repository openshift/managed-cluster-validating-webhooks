package service

import (
	"encoding/json"
	"fmt"
	"reflect"
	"testing"

	patchengine "github.com/evanphx/json-patch"
	jsonpatchtype "gomodules.xyz/jsonpatch/v2"
	admissionv1 "k8s.io/api/admission/v1"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"

	"github.com/openshift/managed-cluster-validating-webhooks/pkg/testutils"
)

const patchPath string = "/metadata/annotations/service.beta.kubernetes.io~1aws-load-balancer-additional-resource-tags"

var addJSONPatchOp jsonpatchtype.Operation = jsonpatchtype.NewOperation("add",
	patchPath,
	"red-hat-managed=true",
)

// Begin Integration Tests
const testServiceJSONString string = `
{
	"apiVersion": "v1",
	"kind": "Service",
	"metadata": {
		"name": "testservice",
		"uid": "1234"%s
	},
	"spec": {
		"type": "LoadBalancer",
		"ports": [
            {
                "name": "http",
                "nodePort": 32259,
                "port": 80,
                "protocol": "TCP",
                "targetPort": "http"
            }
        ],
		"allocateLoadBalancerNodePorts": true,
        "clusterIP": "172.30.52.218"
	}
}`

type serviceTestArgs struct {
	testID    string
	operation admissionv1.Operation
	// oldObjectAnnotations will trigger the creation of a Service to fill AdmissionRequest.OldObject,
	// which is typically only populated for DELETE and UPDATE operations (other operations can leave
	// this field nil). For example, in an UPDATE operation, OldObject represents the Service as it
	// was before the user requested an UPDATE, and Object (which will be annotated using the
	// originalAnnotations field) represents the state of the Service desired by the user post-UPDATE
	oldObjectAnnotations map[string]string
	originalAnnotations  map[string]string
	expectedAnnotations  map[string]string
	shouldBeAllowed      bool
}

// createJSONByteArrayService returns a JSON byte-string of a mock Service with the given
// annotations
func createJSONByteArrayService(annotations map[string]string) []byte {
	if annotations == nil {
		// nil means no annotations key at all
		return []byte(fmt.Sprintf(testServiceJSONString, ""))
	}
	if len(annotations) == 0 {
		// empty map means annotations key exists but is empty
		return []byte(fmt.Sprintf(testServiceJSONString, ",\n\t\t\"annotations\": {}"))
	}
	annotationsMarshaled, _ := json.Marshal(annotations)
	var annotationsByteArray []byte = append([]byte(",\n\t\t\"annotations\": "), annotationsMarshaled...)
	return []byte(fmt.Sprintf(testServiceJSONString, annotationsByteArray))
}

func runServiceTest(t *testing.T, tArgs serviceTestArgs) {
	gvk := metav1.GroupVersionKind{
		Group:   "",
		Version: "v1",
		Kind:    "Service",
	}
	gvr := metav1.GroupVersionResource{
		Group:    "",
		Version:  "v1",
		Resource: "services",
	}

	// For certain ops, create JSON and raw representations of the "old" Service object
	// See docstring for serviceTestArgs.oldObjectAnnotations
	var oldObjectServiceRawPtr *runtime.RawExtension
	if tArgs.oldObjectAnnotations != nil {
		oldObjectServiceJSONByteArray := createJSONByteArrayService(tArgs.oldObjectAnnotations)
		oldObjectServiceRawPtr = &runtime.RawExtension{Raw: oldObjectServiceJSONByteArray}
	}

	// Create JSON and raw representations of the original Service object
	originalServiceJSONByteArray := createJSONByteArrayService(tArgs.originalAnnotations)
	originalServiceRawPtr := &runtime.RawExtension{Raw: originalServiceJSONByteArray}

	// Set up the Webhook under test
	// Note that this webhook doesn't care about RBAC, so we hardcode dummy RBAC parameter values
	hook := NewWebhook()
	httprequest, err := testutils.CreateHTTPRequest(hook.GetURI(),
		tArgs.testID, gvk, gvr, tArgs.operation, "my_user", []string{"my_group"}, "my_ns", originalServiceRawPtr, oldObjectServiceRawPtr)
	if err != nil {
		t.Fatalf("Expected no error, got %s", err.Error())
	}

	// Get the result of the Webhook
	response, err := testutils.SendHTTPRequest(httprequest, hook)
	if err != nil {
		t.Fatalf("Expected no error, got %s", err.Error())
	}

	// Test if request should be allowed at all (true even for responses with patches)
	if response.Allowed != tArgs.shouldBeAllowed {
		t.Fatalf(
			"Mismatch: %s (groups=%s) %s %s, but the Test's expectation is that the user %s",
			"username",
			[]string{"usergroups"},
			testutils.CanCanNot(response.Allowed),
			tArgs.operation,
			testutils.CanCanNot(tArgs.shouldBeAllowed),
		)
	}

	// Decode and apply the patch generated by the Webhook
	patch, err := patchengine.DecodePatch(response.Patch)
	if err != nil {
		// Only a problem for non-empty patches
		if len(patch) > 0 {
			t.Fatalf("Expected no error, got %s while decoding response.Patch", err.Error())
		}
	}
	mutatedServiceJSONByteArray, err := patch.Apply(originalServiceJSONByteArray)
	if err != nil {
		if len(patch) > 0 {
			t.Fatalf("Expected no error, got %s while applying response.Patch", err.Error())
		}
		// Patch is empty (no-op), so just copy original
		mutatedServiceJSONByteArray = originalServiceJSONByteArray
	}

	// Test if mutated Webhook is equal to the expected Webhook
	var mutatedService, expectedService corev1.Service
	json.Unmarshal(mutatedServiceJSONByteArray, &mutatedService)
	json.Unmarshal(createJSONByteArrayService(tArgs.expectedAnnotations), &expectedService)
	if !reflect.DeepEqual(mutatedService, expectedService) {
		// Extract annotations and save unannotated copies of original and its mutation
		expectedAnnotations := expectedService.Annotations
		mutatedAnnotations := mutatedService.Annotations
		expectedService.Annotations = nil
		mutatedService.Annotations = nil
		// Compare unannotated Services (there should never be a difference)
		if !reflect.DeepEqual(mutatedService, expectedService) {
			t.Fatalf(
				"Unwanted side effect: the Webhook mutated something other than annotations. Expected %v, but got %v",
				expectedService,
				mutatedService,
			)
		}
		// Annotation-only mismatch
		t.Fatalf(
			"Mismatch: expected mutated Service annotations %v, but got %v",
			expectedAnnotations,
			mutatedAnnotations,
		)
	}

}
func TestServiceMutation(t *testing.T) {
	tests := []serviceTestArgs{
		{
			testID:              "create-unannotated-service",
			operation:           admissionv1.Create,
			originalAnnotations: nil,
			expectedAnnotations: map[string]string{"service.beta.kubernetes.io/aws-load-balancer-additional-resource-tags": "red-hat-managed=true"},
			shouldBeAllowed:     true,
		},
		{
			testID:              "create-service-empty-annotations",
			operation:           admissionv1.Create,
			originalAnnotations: map[string]string{},
			expectedAnnotations: map[string]string{"service.beta.kubernetes.io/aws-load-balancer-additional-resource-tags": "red-hat-managed=true"},
			shouldBeAllowed:     true,
		},
		{
			testID:              "create-service-incorrect-annotation-single",
			operation:           admissionv1.Create,
			originalAnnotations: map[string]string{"service.beta.kubernetes.io/aws-load-balancer-additional-resource-tags": "red-hat-managed=foo"},
			expectedAnnotations: map[string]string{"service.beta.kubernetes.io/aws-load-balancer-additional-resource-tags": "red-hat-managed=true"},
			shouldBeAllowed:     true,
		},
		{
			testID:              "create-service-irrelevant-annotations",
			operation:           admissionv1.Create,
			originalAnnotations: map[string]string{"foo": "bar", "ABC": "123"},
			expectedAnnotations: map[string]string{"service.beta.kubernetes.io/aws-load-balancer-additional-resource-tags": "red-hat-managed=true", "foo": "bar", "ABC": "123"},
			shouldBeAllowed:     true,
		},
		{
			testID:               "update-service-correct-tag-add-irrelevant-annotation",
			operation:            admissionv1.Update,
			oldObjectAnnotations: map[string]string{"service.beta.kubernetes.io/aws-load-balancer-additional-resource-tags": "red-hat-managed=true", "foo": "bar"},
			originalAnnotations:  map[string]string{"service.beta.kubernetes.io/aws-load-balancer-additional-resource-tags": "red-hat-managed=true", "foo": "bar", "ABC": "123"},
			expectedAnnotations:  map[string]string{"service.beta.kubernetes.io/aws-load-balancer-additional-resource-tags": "red-hat-managed=true", "foo": "bar", "ABC": "123"},
			shouldBeAllowed:      true,
		},
		{
			testID:              "create-service-irrelevant-tags",
			operation:           admissionv1.Create,
			originalAnnotations: map[string]string{"service.beta.kubernetes.io/aws-load-balancer-additional-resource-tags": "Foo=Bar,ABC=123"},
			expectedAnnotations: map[string]string{"service.beta.kubernetes.io/aws-load-balancer-additional-resource-tags": "red-hat-managed=true,Foo=Bar,ABC=123"},
			shouldBeAllowed:     true,
		},
		{
			testID:               "update-service-correct-tag-deletion-attempt", // OSD-21590 regression test
			operation:            admissionv1.Update,
			oldObjectAnnotations: map[string]string{"service.beta.kubernetes.io/aws-load-balancer-additional-resource-tags": "red-hat-managed=true,Foo=Bar,ABC=123"},
			originalAnnotations:  map[string]string{"service.beta.kubernetes.io/aws-load-balancer-additional-resource-tags": "Foo=Bar,ABC=123"},
			expectedAnnotations:  map[string]string{"service.beta.kubernetes.io/aws-load-balancer-additional-resource-tags": "red-hat-managed=true,Foo=Bar,ABC=123"},
			shouldBeAllowed:      true,
		},
		{
			testID:               "update-service-correct-tag-modification-attempt", // OSD-21590 regression test
			operation:            admissionv1.Update,
			oldObjectAnnotations: map[string]string{"service.beta.kubernetes.io/aws-load-balancer-additional-resource-tags": "red-hat-managed=true,Foo=Bar,ABC=123"},
			originalAnnotations:  map[string]string{"service.beta.kubernetes.io/aws-load-balancer-additional-resource-tags": "red-hat-managed=foobar,Foo=Bar,ABC=123"},
			expectedAnnotations:  map[string]string{"service.beta.kubernetes.io/aws-load-balancer-additional-resource-tags": "red-hat-managed=true,Foo=Bar,ABC=123"},
			shouldBeAllowed:      true,
		},
		{
			testID:               "create-service-correct-tag",
			operation:            admissionv1.Create,
			oldObjectAnnotations: map[string]string{"service.beta.kubernetes.io/aws-load-balancer-additional-resource-tags": "red-hat-managed=true"},
			originalAnnotations:  map[string]string{"service.beta.kubernetes.io/aws-load-balancer-additional-resource-tags": "red-hat-managed=true"},
			expectedAnnotations:  map[string]string{"service.beta.kubernetes.io/aws-load-balancer-additional-resource-tags": "red-hat-managed=true"},
			shouldBeAllowed:      true,
		},
		{
			testID:              "update-service-correct-tags",
			operation:           admissionv1.Update,
			originalAnnotations: map[string]string{"service.beta.kubernetes.io/aws-load-balancer-additional-resource-tags": "red-hat-managed=true,Foo=Bar,ABC=123"},
			expectedAnnotations: map[string]string{"service.beta.kubernetes.io/aws-load-balancer-additional-resource-tags": "red-hat-managed=true,Foo=Bar,ABC=123"},
			shouldBeAllowed:     true,
		},
		{
			testID:              "create-malformed-tags",
			operation:           admissionv1.Create,
			originalAnnotations: map[string]string{"service.beta.kubernetes.io/aws-load-balancer-additional-resource-tags": "!@#$"},
			expectedAnnotations: map[string]string{"service.beta.kubernetes.io/aws-load-balancer-additional-resource-tags": "red-hat-managed=true,!@#$"},
			shouldBeAllowed:     true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.testID, func(t *testing.T) { runServiceTest(t, tt) })
	}
}

// End Integration Tests

// Begin Unit Tests
func Test_buildPatch(t *testing.T) {
	type args struct {
		serviceAnnotations map[string]string
	}
	tests := []struct {
		name string
		args args
		want jsonpatchtype.JsonPatchOperation
	}{
		{
			name: "nil annotations",
			args: args{
				serviceAnnotations: nil,
			},
			want: jsonpatchtype.NewOperation(
				"add",
				"/metadata/annotations",
				map[string]string{"service.beta.kubernetes.io/aws-load-balancer-additional-resource-tags": "red-hat-managed=true"},
			),
		},
		{
			name: "empty annotations",
			args: args{
				serviceAnnotations: map[string]string{},
			},
			want: addJSONPatchOp,
		},
		{
			name: "irrelevant existing annotations",
			args: args{
				serviceAnnotations: map[string]string{
					"foo": "bar",
					"machineconfiguration.openshift.io/controlPlaneTopology": "HighlyAvailable",
					"k8s.ovn.org/host-cidrs":                                 "[\"10.0.0.107/24\"]",
				},
			},
			want: addJSONPatchOp,
		},
		{
			name: "irrelevant existing resource tags",
			args: args{
				serviceAnnotations: map[string]string{
					"service.beta.kubernetes.io/aws-load-balancer-additional-resource-tags": "Foo=Bar,ABC=123",
				},
			},
			want: jsonpatchtype.NewOperation("replace",
				patchPath,
				"red-hat-managed=true,Foo=Bar,ABC=123",
			),
		},
		{
			name: "relevant existing resource tags",
			args: args{
				serviceAnnotations: map[string]string{
					"service.beta.kubernetes.io/aws-load-balancer-additional-resource-tags": "Foo=Bar,red-hat-managed=foobar",
				},
			},
			want: jsonpatchtype.NewOperation("replace",
				patchPath,
				"red-hat-managed=true,Foo=Bar",
			),
		},
		{
			name: "multiple relevant existing resource tags",
			args: args{
				serviceAnnotations: map[string]string{
					"service.beta.kubernetes.io/aws-load-balancer-additional-resource-tags": "red-hat-managed=false,Foo=Bar,red-hat-managed=foobar",
				},
			},
			want: jsonpatchtype.NewOperation("replace",
				patchPath,
				"red-hat-managed=true,Foo=Bar",
			),
		},
		{
			name: "correct existing tags",
			args: args{
				serviceAnnotations: map[string]string{
					"service.beta.kubernetes.io/aws-load-balancer-additional-resource-tags": "red-hat-managed=true,Foo=Bar,ABC=123",
				},
			},
			// Ideally, this never happens because the calling function won't try to build a
			// Patched() response if hasRedHatManagedTag() == true. If this does happen though,
			// we should return a replace operation that's effectively a no-op
			want: jsonpatchtype.NewOperation("replace",
				patchPath,
				"red-hat-managed=true,Foo=Bar,ABC=123",
			),
		},
		{
			name: "malformed existing resource tag",
			args: args{
				serviceAnnotations: map[string]string{
					"service.beta.kubernetes.io/aws-load-balancer-additional-resource-tags": "#!&^",
				},
			},
			// We're not in the business of enforcing correct AWS tag syntax. If a resource tags
			// annotation is unacceptable before passing through this webhook, no need for us to
			// try to "save" it beyond inserting the required tag safely
			want: jsonpatchtype.NewOperation("replace",
				patchPath,
				"red-hat-managed=true,#!&^",
			),
		},
		{
			name: "multiple malformed existing resource tags",
			args: args{
				serviceAnnotations: map[string]string{
					"service.beta.kubernetes.io/aws-load-balancer-additional-resource-tags": "!,,$,",
				},
			},
			// See above comment
			want: jsonpatchtype.NewOperation("replace",
				patchPath,
				"red-hat-managed=true,!,,$,",
			),
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := buildPatch(tt.args.serviceAnnotations); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("buildPatch() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_hasRedHatManagedTag(t *testing.T) {
	type args struct {
		serviceAnnotations map[string]string
	}
	tests := []struct {
		name string
		args args
		want bool
	}{
		{
			name: "happy path single tag",
			args: args{
				serviceAnnotations: map[string]string{
					"service.beta.kubernetes.io/aws-load-balancer-additional-resource-tags": "red-hat-managed=true",
				},
			},
			want: true,
		},
		{
			name: "happy path with noise",
			args: args{
				serviceAnnotations: map[string]string{
					"foo": "bar",
					"machineconfiguration.openshift.io/controlPlaneTopology":                "HighlyAvailable",
					"service.beta.kubernetes.io/aws-load-balancer-additional-resource-tags": "red-hat-managed=true,Foo=Bar,ABC=123",
				},
			},
			want: true,
		},
		{
			name: "irrelevant annotations",
			args: args{
				serviceAnnotations: map[string]string{
					"foo": "bar",
					"machineconfiguration.openshift.io/controlPlaneTopology": "HighlyAvailable",
					"k8s.ovn.org/host-cidrs":                                 "[\"10.0.0.107/24\"]",
				},
			},
			want: false,
		},
		{
			name: "incorrect tag values",
			args: args{
				serviceAnnotations: map[string]string{
					"service.beta.kubernetes.io/aws-load-balancer-additional-resource-tags": "red-hat-managed=false,Foo=Bar,ABC=123",
				},
			},
			want: false,
		},
		{
			name: "incorrect tag value alone",
			args: args{
				serviceAnnotations: map[string]string{
					"service.beta.kubernetes.io/aws-load-balancer-additional-resource-tags": "red-hat-managed=foo",
				},
			},
			want: false,
		},
		{
			name: "correct tag surrounded by garbage",
			args: args{
				serviceAnnotations: map[string]string{
					"service.beta.kubernetes.io/aws-load-balancer-additional-resource-tags": ",,red-hat-managed=true,#$%^",
				},
			},
			want: true,
		},
		{
			name: "empty annotations",
			args: args{
				serviceAnnotations: map[string]string{},
			},
			want: false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := hasRedHatManagedTag(tt.args.serviceAnnotations); got != tt.want {
				t.Errorf("hasRedHatManagedTag() = %v, want %v", got, tt.want)
			}
		})
	}
}
