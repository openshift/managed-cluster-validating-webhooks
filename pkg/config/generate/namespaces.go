//go:build ignore
// +build ignore

package main

import (
	"bufio"
	"fmt"
	"log"
	"net/http"
	"os"
	"text/template"

	"github.com/ghodss/yaml"
	corev1 "k8s.io/api/core/v1"
)

var namespaceFiles = []string{
	"managed-namespaces.ConfigMap.yaml",
	"ocp-namespaces.ConfigMap.yaml",
}

var (
	// Base lists - default values which will always be enforced regardless of managed-cluster-config
	namespaces = []string{"^kube.*", "^default$", "^redhat.*"}
	configmaps = []string{}
)

const (
	// generatedFileName defines the path to the generated file relative to the invoking go:generate command
	generatedFileName = "./namespaces.go"

	mccBaseUrl           = "https://raw.githubusercontent.com/openshift/managed-cluster-config/master/deploy/osd-managed-resources"
	serviceAccountHeader = `^system:serviceaccounts:`
	namespacesKey        = "managed_namespaces.yaml"
)

const templateText = `// Code generated by pkg/config/generate/namespaces.go; DO NOT EDIT.
package config

var ConfigMapSources = []string{
{{- range .ConfigMaps }}
	"{{ printf "%s" . }}",
{{- end }}
}

var PrivilegedNamespaces = []string{
{{- range .Namespaces }}
	"{{ printf "%s" . }}",
{{- end }}
}
`

type templateArgs struct {
	ConfigMaps      []string
	Namespaces      []string
	ServiceAccounts []string
}

// ManagedNamespacesConfig defines the structure of the managed_namespaces.yaml file from the managed-namespaces ConfigMap
type NamespacesConfig struct {
	Resources NamespaceList `yaml:"Resources,omitempty" json:"Resources,omitempty"`
}

type NamespaceList struct {
	Namespace []Namespace `yaml:"Namespace,omitempty" json:"Namespace,omitempty"`
}

type Namespace struct {
	Name string `yaml:"name,omitempty" json:"name,omitempty"`
}

func main() {
	// Retrieve current configuration from managed-cluster-config
	for _, fileName := range namespaceFiles {
		// GET files and read contents
		fileUrl := fmt.Sprintf("%s/%s", mccBaseUrl, fileName)
		response, err := http.Get(fileUrl)
		if err != nil {
			log.Fatalf("Error retrieving file from managed-cluster-config: %v", err)
			return
		}
		defer func() {
			err := response.Body.Close()
			if err != nil {
				log.Fatalf("Error closing response body: %v", err)
			}
		}()

		scanner := bufio.NewScanner(response.Body)
		rawFile := []byte{}
		for scanner.Scan() {
			rawFile = append(rawFile, scanner.Bytes()...)
			// Newlines must be manually appended, Scan() only reads in the line contents
			rawFile = append(rawFile, []byte("\n")...)
		}
		if scanner.Err() != nil {
			log.Fatalf("Error reading response body: %v", scanner.Err())
		}

		// Convert file contents to ConfigMap; convert ConfigMap data to NamespaceConfig format
		nsConfigMap := corev1.ConfigMap{}
		err = yaml.Unmarshal(rawFile, &nsConfigMap)
		if err != nil {
			log.Fatalf("Error decoding response: %v", err)
		}

		rawConfig := []byte(nsConfigMap.Data[namespacesKey])
		nsConfig := NamespacesConfig{}
		err = yaml.Unmarshal(rawConfig, &nsConfig)
		if err != nil {
			log.Fatalf("Error decoding configMap: %v", err)
		} else if len(nsConfig.Resources.Namespace) == 0 {
			log.Fatalf("No namespaces retrieved from %s", fileName)
		}

		// Save retrieved namespaces, serviceaccounts, and configmap info
		configmaps = append(configmaps, fmt.Sprintf("%s/%s", nsConfigMap.Namespace, nsConfigMap.Name))
		for _, ns := range nsConfig.Resources.Namespace {
			namespaces = append(namespaces, "^"+ns.Name+"$")
		}
	}

	// Write data to file
	genFile, err := os.Create(generatedFileName)
	if err != nil {
		log.Fatalf("Error creating file %s: %v", generatedFileName, err)
	}
	defer func() {
		err = genFile.Close()
		if err != nil {
			log.Fatalf("Error closing file %s: %v", genFile.Name(), err)
		}
	}()

	namespaceTemplateArgs := templateArgs{
		ConfigMaps: configmaps,
		Namespaces: namespaces,
	}
	namespaceTemplate, err := template.New(generatedFileName).Parse(templateText)
	if err != nil {
		log.Fatalf("Error initializing template: %v", err)
	}

	err = namespaceTemplate.Execute(genFile, namespaceTemplateArgs)
	if err != nil {
		log.Fatalf("Error generating file from template: %v", err)
	}
}
